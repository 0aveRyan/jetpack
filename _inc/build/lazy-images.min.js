/* Do not modify this file directly. It is compiled from other files. */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* global IntersectionObserver, Promise */

/**
 * Huge props to deanhume for https://github.com/deanhume/lazy-observer-load
 * TODO: IntersectionObserver polyfill: https://github.com/w3c/IntersectionObserver/tree/gh-pages/polyfill
 */
// Get all of the images that are marked up to lazy load
( function() {
	const images = document.querySelectorAll( 'img[data-lazy-src]' );
	const config = {
		// If the image gets within 50px in the Y axis, start the download.
		rootMargin: '50px 0px',
		threshold: 0.01
	};

	let imageCount = images.length;
	let observer;

	// If we don't have support for intersection observer, loads the images immediately
	if ( ! ( 'IntersectionObserver' in window ) ) {
		loadImagesImmediately( images );
	} else {
		// It is supported, load the images
		observer = new IntersectionObserver( onIntersection, config );

		// foreach() is not supported in IE
		for ( let i = 0; i < images.length; i++ ) {
			const image = images[ i ];
			if ( image.classList.contains( 'jetpack-lazy-image--handled' ) ) {
				continue;
			}

			observer.observe( image );
		}
	}

	/**
	 * Fetchs the image for the given URL
	 * @param {string} url
	 * @returns {Promise}
	 */
	function fetchImage( url ) {
		return new Promise( ( resolve, reject ) => {
			const image = new Image();
			image.src = url;
			image.onload = resolve;
			image.onerror = reject;
		} );
	}

	/**
	 * Preloads the image
	 * @param {object} image
	 * @returns {Promise}
	 */
	function preloadImage( image ) {
		const src = image.dataset.lazySrc;
		if ( ! src ) {
			return;
		}

		const srcset = image.dataset.lazySrcset;

		return fetchImage( src ).then( () => {
			applyImage( image, src, srcset );
		} );
	}

	/**
	 * Load all of the images immediately
	 * @param {NodeListOf<Element>} immediateImages List of lazy-loaded images to load immediately.
	 */
	function loadImagesImmediately( immediateImages ) {
		// foreach() is not supported in IE
		for ( let i = 0; i < immediateImages.length; i++ ) {
			const image = immediateImages[ i ];
			preloadImage( image );
		}
	}

	/**
	 * On intersection
	 * @param {array} entries List of elements being observed.
	 */
	function onIntersection( entriesÂ ) {
		// Disconnect if we've already loaded all of the images
		if ( imageCount === 0 ) {
			observer.disconnect();
		}

		// Loop through the entries
		for ( let i = 0; i < entries.length; i++ ) {
			const entry = entries[ i ];
			// Are we in viewport?
			if ( entry.intersectionRatio > 0 ) {
				imageCount--;

				// Stop watching and load the image
				observer.unobserve( entry.target );
				preloadImage( entry.target );
			}
		}
	}

	/**
	 * Apply the image
	 * @param {object} img The image object.
	 * @param {string} src The image source to set.
	 * @param {string} srcset The image srcset to set.
	 */
	function applyImage( img, src, srcset ) {
		// Prevent this from being lazy loaded a second time.
		img.classList.add( 'jetpack-lazy-image--handled' );
		img.src = src;
		img.srcset = srcset;
		img.classList.add( 'fade-in' );
	}
} )();


/***/ })
/******/ ]);